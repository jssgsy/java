# CountDownLatch与CyclicBarrier的区别
* 语义上：
  * CountDownLatch：
    * 某些线程(主)要等待其它线程完成任务后才能开始执行；如接力赛上下一位跑者要等前面一位跑到面前交接棒后才能继续跑；
    * 当调用countDown方法时表示通知主线程已经的任务已经完成了或者说主线程依赖自己的前提任务已经完成；
    * 但自己还可以继续执行其它任务(主线程非依赖的任务)，所以`countDown方法是非阻塞的`；但一般应该是放在任务的最后一句执行，这样才更符合语义；
    * 一般是主线程(调用await方法)要等待子线程(调用countDown方法)；
      * `一个线程等待其它线程`；
    * 小结：核心；调用countDown方法是为了`告知`外界被依赖的、该由自己执行的任务已经完成；
* CyclicBarrier： 
  * 线程间要等相互等待对方到达某个条件后才可继续执行；
    * `线程间相互等待`；都满足条件后各线程再「同时」执行；
  * 没有主、子线程的语义关系在，一般都是独立的线程；
  * ---》因为是相互等待，所以不要在相互等待中出现死锁；
  * await方法是阻塞的，调用后说明自己已经满足了条件，现在要等待其它线程去满足自己的条件；
    * 调用了await就说明自己到达了条件；
* 场景上：
  * CountDownLatch：
    * 跟团旅游时，所有人都到了车上后车才能出发；
    * 麻将时，四人都上桌了才能开始；
  * CyclicBarrier：
    * 吃饭时，所有人到齐了才能动筷；