# 定义
注：如下定义仅仅是最纯粹的责任链模式的定义。
> 是一种行为设计模式。将用来处理请求的一系列对象串成一条链(具体方式是每个处理器持有下一个处理器的引用)。让请求在这个链上传递， 直到链上的某一个对象决定处理此请求。
> 最大的特点：解耦了请求和请求具体的处理者。(发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求)

注：
* `纯粹的模式`本身强调的是对象链中的某个对象会处理请求，但`实际中有一些变体的责任链模式`，如让对象链中的每个对象都对请求进行处理，灵活使用；
* 实际应用中没有纯粹的责任链模式；

# 自己的理解
* 如何`设置后继者是客户端(调用方、模式使用者)的职责`，模式本身并不关心。这是正常的，因为后继者带有业务属性；
* 但其实如何将众多处理器组合起来却是实际使用中的重点和难点；
    * 如使用集合保存所有的处理器，且支持自定义顺序；


# 责任链模式的变体
## 过滤器模式
纯粹责任链模式本身强调的是对象链中的某个对象会处理请求，然后就结束了。但完全可以让对象链的每个对象都对请求进入处理，此即`过滤器`(Filter)和`拦截器`(interceptor)的概念。
此时可以做到：不但允许每个Filter都有机会处理请求，还允许每个Filter决定是否将请求“放行”给下一个Filter。要灵活使用。

常用场景：
1. 记录日志；
2. 权限校验；

# 重点：责任链模式、过滤器、拦截器的区别
主要从语义上区分。
* 责任链模式：强调请求沿着对象链传递，走到有一个对象进行处理；
* 过滤器(Filter)：在目标方法执行之前先执行一系列过滤器的操作；
    * 过滤器的语义是`目标方法最终会被执行到`，只是在执行之前先执行一系列的过滤器；
    * 实际操作一般就是定义一个invoke方法；
* 拦截器(Interceptor)：在目标方法执行前后各执行一系列拦截器的操作，并判断请求是否能往后传递；
    * 实际操作中一般可定义成preHandler与postHandler，且preHandler可定义成boolean，返回false表示请求不能再往后传递了(包括后续的拦截器以及目标方法)  
* 注：上面是从语义方面区别，实际使用中不要教条；
    * 如Filter也可用一个方法实现目标方法前后都执行一些操作(在invoke方法前、后都执行一段逻辑)；
    * 如Interceptor也不一定非要定义出preHandler与postHandler方法，也可集成到一个方法中；
    
    


# UML类图
![纯的责任链模式](https://github.com/jssgsy/java/raw/master/src/main/java/com/univ/patterndesign/chain/chain_uml.png)